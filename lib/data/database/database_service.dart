import 'package:drift/drift.dart';
import 'connection/connection.dart' as dbconn;
import 'package:flutter_notebook/data/database/sort_order.dart';
import 'package:riverpod/riverpod.dart';

import 'tables/category.dart';
import 'tables/note.dart';

// Generated by drift_dev when running `build_runner build`
part 'database_service.g.dart';

@DriftDatabase(tables: [Notes, Categories])
class DatabaseService extends _$DatabaseService {
  DatabaseService(super.connection);

  // Create a new database service with the default connection
  factory DatabaseService.withDefaultConnection() {
    return DatabaseService(dbconn.Connection.getDatabaseConnection());
  }

  @override
  int get schemaVersion => 1;

  @override
  MigrationStrategy get migration {
    return MigrationStrategy(
      beforeOpen: (details) async {
        // Make sure that foreign keys are enabled
        await customStatement('PRAGMA foreign_keys = ON');

        if (details.wasCreated) {
          // Create default records here
          await into(categories).insert(
            CategoriesCompanion.insert(name: 'Default'),
          );
        }
      },
    );
  }

  // Returns an auto-updating stream of all notes in a given category
  // If categoryId is null, all notes are returned
  Stream<List<NoteWithCategory>> listNotesInCategory(int? categoryId,
      [SortOrder sortOrder = SortOrder.oldest]) {
    final query = select(notes).join([
      leftOuterJoin(
          categories, categories.categoryId.equalsExp(notes.categoryId))
    ]);

    if (categoryId != null) {
      query.where(categories.categoryId.equals(categoryId));
    }

    if (sortOrder == SortOrder.az) {
      query.orderBy([OrderingTerm(expression: notes.title)]);
    } else if (sortOrder == SortOrder.za) {
      query.orderBy(
          [OrderingTerm(expression: notes.title, mode: OrderingMode.desc)]);
    } else if (sortOrder == SortOrder.newest) {
      query.orderBy([
        OrderingTerm(expression: notes.modifiedDate, mode: OrderingMode.desc)
      ]);
    } else if (sortOrder == SortOrder.oldest) {
      query.orderBy([OrderingTerm(expression: notes.modifiedDate)]);
    }

    return query.map((row) {
      return NoteWithCategory(
        note: row.readTable(notes),
        category: row.readTableOrNull(categories),
      );
    }).watch();
  }

  Stream<List<Note>> listAllNotes() {
    return (select(notes)).watch();
  }

  Future<int> saveNote(
      {int? id,
      required String title,
      required String description,
      int? categoryId}) {
    return into(notes).insertOnConflictUpdate(
      NotesCompanion.insert(
        noteId: id == null ? const Value.absent() : Value(id),
        title: title,
        description: description,
        categoryId: Value(categoryId),
        modifiedDate: DateTime.now(),
      ),
    );
  }

  Future<int> deleteNote(int id) {
    return (delete(notes)..where((n) => n.noteId.equals(id))).go();
  }

  Stream<List<Category>> listAllCategories() {
    return (select(categories)).watch();
  }

  Future<int> saveCategory({int? id, required String name}) {
    return into(categories).insertOnConflictUpdate(
      CategoriesCompanion.insert(
          categoryId: id == null ? const Value.absent() : Value(id),
          name: name),
    );
  }

  Future<int> deleteCategory(int categoryId) {
    return transaction(() async {
      // First, move note entries that might remain into the default category
      await (notes.update()
            ..where((note) => note.categoryId.equals(categoryId)))
          .write(const NotesCompanion(categoryId: Value(null)));

      // Then, delete the category
      return (delete(categories)..where((c) => c.categoryId.equals(categoryId)))
          .go();
    });
  }

  // Provider for the database service
  // Note: Declared here as Provider.  If the database connection was to change
  // at some point (for example the database connection is reset and
  // reinitialised after a backup / restore) we would need to declare this as a
  // StateProvider instead.
  static final Provider<DatabaseService> provider = Provider((ref) {
    final database = DatabaseService.withDefaultConnection();
    ref.onDispose(database.close);

    return database;
  });
}

class NoteWithCategory {
  final Note note;
  final Category? category;

  NoteWithCategory({required this.note, this.category});
}
